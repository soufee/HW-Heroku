// TODO: Fix dependency cycle
// eslint-disable-next-line import/no-cycle
import { getBinderNode, NumberModel } from './Models.js';
// eslint-disable-next-line import/no-cycle
import { Required } from './Validators.js';
export class ValidationError extends Error {
    constructor(errors) {
        super([
            'There are validation errors in the form.',
            ...errors.map((e) => `${e.property} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ''}`),
        ].join('\n - '));
        this.errors = errors;
        this.name = this.constructor.name;
    }
}
export class ServerValidator {
    constructor(message) {
        this.validate = () => false;
        this.message = message;
    }
}
export async function runValidator(model, validator, interpolateMessageCallback) {
    const binderNode = getBinderNode(model);
    const { value } = binderNode;
    const interpolateMessage = (message) => {
        if (!interpolateMessageCallback) {
            return message;
        }
        return interpolateMessageCallback(message, validator, binderNode);
    };
    // If model is not required and value empty, do not run any validator. Except
    // always validate NumberModel, which has a mandatory builtin validator
    // to indicate NaN input.
    if (!getBinderNode(model).required && !new Required().validate(value) && !(model instanceof NumberModel)) {
        return [];
    }
    return (async () => validator.validate(value, getBinderNode(model).binder))().then((result) => {
        if (result === false) {
            return [
                { property: getBinderNode(model).name, value, validator, message: interpolateMessage(validator.message) },
            ];
        }
        if (result === true || (Array.isArray(result) && result.length === 0)) {
            return [];
        }
        if (Array.isArray(result)) {
            return result.map((result2) => ({
                message: interpolateMessage(validator.message),
                ...result2,
                value,
                validator,
            }));
        }
        return [{ message: interpolateMessage(validator.message), ...result, value, validator }];
    });
}
//# sourceMappingURL=Validation.js.map